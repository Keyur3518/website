<h1>Documentation</h1>

<h2 id="table-of-contents">Table of Contents</h2>

<ul>
  <li><a href="#introduction">Introduction</a></li>
  <li>
    <a href="#usage">Usage</a>
    <ul>
      <li><a href="#generating-a-parser">Generating a Parser</a></li>
      <li><a href="#using-the-generated-parser">Using the Generated Parser</a></li>
    </ul>
  </li>
  <li>
    <a href="#grammar">Grammar</a>
    <ul>
      <li><a href="#parsing-expression-types">Parsing Expression Types</a></li>
    </ul>
  </li>
  <li><a href="#compatibility">Compatibility</a></li>
</ul>

<h2 id="introduction">Introduction</h2>

<p>PEG.js is a parser generator for JavaScript based on the
<a href="http://en.wikipedia.org/wiki/Parsing_expression_grammar">parsing expression grammar</a>
formalism. It is designed to be used either from your browser or from the command line (using
<a href="http://www.mozilla.org/rhino/">Rhino</a>
JavaScript interpreter).</p>

<h2 id="usage">Usage</h2>

<p>To use PEG.js, you need to generate a parser from your grammar and then use
the generated parser in your project.</p>

<h3 id="generating-a-parser">Generating a Parser</h3>

<p>To generate a parser, you can use the <a href="online">online generator</a>
or the command line. For the second option, you need to have Java installed.
Than you can generate the parser using the <code>bin/pegjs</code> script on Unix
or <code>bin/pegjs.bat</code> batch file on Windows:</p>

<pre><code>$ bin/pegjs arithmeticsParser examples/arithmetics.pegjs</code></pre>

<p>This command will create the parser from the
<code>examples/arithmetics.pegjs</code> file and put in into the
<code>examples/arithmetics.js</code> file. The generated parser will be
available in the <code>arithmeticsParser</code> global variable. The generator
has several useful options&mdash;to learn more about them, use
<code>--help</code>.</p>

<h3 id="using-the-generated-parser">Using the Generated Parser</h3>

<p>To use the parser in a web page, follow the following example:</p>

<pre><code>&lt;!DOCTYPE html&gt;
&lt;head&gt;
  &lt;title&gt;Arithmetics Parser Example&lt;title&gt;
  &lt;script src="examples/arithmetics.js"&gt;&lt;script&gt; &lt;!-- Include the parser. --&gt;
  &lt;script&gt;
    function calculate(expression) {
      /* Use the parser to compute a value of an arithmetic expression. */
      var result;
      try {
        result = arithmeticsParser.parse(document.getElementById("expression").value);
      } catch (e) {
        result = e.message;
      }
      document.getElementById("result").innerText = result;
    }
  &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;input type="text" id="expression" value="2*(3+4)"&gt;
  &lt;input type="button" value="Calculate" onclick="calculate();"&gt;
  &lt;div id="result"&gt;&lt;div&gt;
&lt;/body&gt;</code></pre>

<p>The <code>parse</code> method of the generated parser will return either
the result of the parsing (dependent on the actions you specified in the
grammar) or throw <code>PEG.Parser.SyntaxError</code> exception if the input
contains a syntax error. The exception has properties <code>message</code>,
<code>line</code> and <code>column</code>, which contain details about the
error.</p>

<h2 id="grammar">Grammar</h2>

<p>The grammar syntax is similar to JavaScript in that it is not line-oriented
and it ignores whitespace between tokens. You can also use JavaScript-style
comments (<code>// ...</code> and <code>/* ... */</code>).</p>

<p>Let's look at an example grammar, which recognizes simple arithmetic
expressions like <code>2*(3+4)</code>. The parser generated from this grammar
then computes their value.</p>

<pre><code>start             : additive

additive          : multiplicative "+" additive { return $1 + $3; }
                  / multiplicative

multiplicative    : primary "*" multiplicative { return $1 * $3; }
                  / primary

primary           : integer
                  / "(" additive ")" { return $2; }

integer "integer" : [0-9]+ { return parseInt($1.join(""), 10); }</code></pre>

<p>On the top level, the grammar consists of <em>rules</em> (in our example,
there are five of them). Each rule contains a <em>name</em> (e.g.
<code>integer</code>, which identifies the rule, and a <em>parsing
expression</em> (e.g. <code>[0-9]+ { return parseInt($1.join(""), 10);
}</code>), which prescribes a pattern to match against the input text and
possibly contains some JavaScript code that determines what happens when the
pattern matches successfully. Rules can also contain <em>human-readable
name</em>, which is used in error messages (in our example, only the
<code>integer</code> rule has a human-readable name). One of the rules is the
<em>start rule</em> (by default this is the one named "start", but this can be
changed when generating the parser).</p>

<p class="center">
  <img src="/img/rule.png" width="790" height="100" alt="PEG.js grammar rule">
</p>

<p>Rule name must be a JavaScript identifier and it is followed by a colon (":")
and the rule parsing expression. If the rule has a human-readable name, it is
written as a JavaScript string between the name and separating colon. Rules need
to be separated only by whitespace (their beginning is easily recognizable, so
no separator is needed).</p>

<p>The parsing expression of the rules are used to match the input text to the
grammar. There are various types of expressions&mdash;matching characters or
character classes, indicating optional parts and repetition, etc. (see <a
href="#parsing-expression-types">description below</a>). Expressions can also
contain references to other rules.</p>

<p>If an expression successfully matches a part of the text when running the
generated parser, it produces a <em>match result</em>, which is a JavaScript
value. For example, an expression matching a literal string produces a
JavaScript string with the matched part and an expression matching repeated
occurrence of some subexpression produces a JavaScript array with all the
matches. The match results propagate through the rules when the rule names are
used in expressions. As a result, a match result of the expression in the start
rule becomes the value that the generated parser returns when the parsing is
successful.</p>

<p>One special case of parser expression is a <em>parser action</em>&mdash;a
piece of JavaScript code inside curly braces (<code>{</code>, <code>}</code>),
which gets the match result of the preceding expression in its arguments and can
return a Javacript value. This value will be considered as the match result of
the preceding expression (in other words, the parser actions are basically match
result transformers).</p>

<p>In our arithmetics, there are many parser actions. As an example, consider
the action in expression <code>[0-9]+ { return parseInt($1.join(""), 10);
}</code>. It takes the match result of the expression <code>[0-9]+</code>,
which is an array of strings containing digits, as its parameter. It joins the
digits together to form a number and convets it to a JavaScript
<code>number</code> object.</p>

<h3 id="parsing-expression-types">Parsing Expression Types</h3>

<p>There are several types of parsing expressions, some of them containing
subexpressions and thus forming a recursive structure:</p>

<dl>
  <dt><code><em>rule</em></code></dt>
  <dd>Match a parsing expression of a rule recursively and return its match
  result.</dd>

  <dt>
    <code>"<em>literal</em>"</code><br>
    <code>'<em>literal</em>'</code>
  </dt>

  <dd>Match exact literal string and return it. The string syntax is the same as
  in JavaScript.</dd>

  <dt><code>.</code></dt>
  <dd>Match exactly one character and return it as a string.</dd>

  <dt><code>[<em>characters</em>]</code></dt>

  <dd>Match one character from a set and return it as a string. The characters
  in the list can be escaped in exactly the same way as in JavaScript string.
  The list of characters can also contain ranges, e.g. <code>a-z</code>.
  Preceding the characters with <code>^</code> inverts the matched set (e.g.
  <code>[^a-z]</code>).</dd>

  <dt><code>( <em>expression</em> )</code></dt>

  <dd>Match a subexpression and return its match result.</dd>

  <dt><code><em>expression</em> *</code></dt>

  <dd>Match zero or more repetitions of the expression and return their match
  results in an array. The matching is greedy, i.e. the parser tries to match as
  much expressions as possible.</dd>

  <dt><code><em>expression</em> +</code></dt>

  <dd>Match one or more repetitions of the expression and return their match
  results in an array. The matching is greedy, i.e. the parser tries to match as
  much expressions as possible.</dd>

  <dt><code><em>expression</em> ?</code></dt>

  <dd>Try to match the expression. If the match succeeds, return its match
  result, otherwise return an empty string.</dd>

  <dt><code>& <em>expression</em></code></dt>

  <dd>Try to match the expression and if the match succeeds, just return
  <code>null</code> and do not advance the parser position.</dd>

  <dt><code>! <em>expression</em></code></dt>

  <dd>Try to match the expression and if the match does not succeed, just return
  <code>null</code> and do not advance the parser position.</dd>

  <dt><code><em>expression<sub>1</sub></em> <em>expression<sub>2</sub></em> ...  <em>expression<sub>n</sub></em></code></dt>

  <dd>Match a sequence of expression and return their match results in an array.</dd>

  <dt><code><em>expression</em> { <em>action</em> }</code></dt>

  <dd>
    <p>Match the expression and if the match is successful, run the action,
    otherwise return <code>null</code>.</p>

    <p>The action is a piece of JavaScript code, which gets the match result of
    the preceding expression in its arguments (if the preceding expression is a
    sequence, the matched parts are splatted into many arguments, otherwise only
    one argument is passed). The arguments can be accessed using
    <code>$1</code>, <code>$2</code>, etc., or using normal JavaScript
    <code>arguments</code> object. The action should return some JavaScript
    value using the <code>return</code> statement. This value will be considered
    as the match result of the preceding expression. The action can return
    <code>null</code> to indicate a match failure.</p>
  </dd>

  <dt><code><em>expression<sub>1</sub></em> / <em>expression<sub>2</sub></em> / ... / <em>expression<sub>n</sub></em></code></dt>

  <dd>Try to match the first expression, if it does not succeed, try the
  second one, etc. Return the match result of the first successfully matched
  expression, or <code>null</code> if no expression matches.</dd>
</dl>

<h2 id="compatibility">Compatibility</h2>

<p>Both the parser generator and generated parsers should run well in IE6+ and
recent versions of Firefox, Chrome, Safari and Opera, as well as Rhino
JavaScript engine.</p>
